[DEBUG nls::linearization::building] parent referenced a record field Known(ItemId { file_id: FileId(1), index: 25 })
[DEBUG nls::linearization::building] Associating child fold_left to value Some((ItemId { file_id: FileId(1), index: 35 }, RecordField { ident: Ident { label: "fold_left" }, record: ItemId { file_id: FileId(1), index: 25 }, usages: [ItemId { file_id: FileId(1), index: 242 }, ItemId { file_id: FileId(1), index: 260 }, ItemId { file_id: FileId(1), index: 376 }, ItemId { file_id: FileId(1), index: 604 }, ItemId { file_id: FileId(3), index: 12 }], value: Known(ItemId { file_id: FileId(1), index: 143 }) }))
[DEBUG nls::linearization::building] Associating child array to value Some((ItemId { file_id: FileId(1), index: 1 }, RecordField { ident: Ident { label: "array" }, record: ItemId { file_id: FileId(1), index: 0 }, usages: [ItemId { file_id: FileId(3), index: 11 }, ItemId { file_id: FileId(3), index: 23 }], value: Known(ItemId { file_id: FileId(1), index: 25 }) }))
[DEBUG nls::linearization::building] parent referenced a record field Known(ItemId { file_id: FileId(1), index: 25 })
[DEBUG nls::linearization::building] Associating child append to value Some((ItemId { file_id: FileId(1), index: 38 }, RecordField { ident: Ident { label: "append" }, record: ItemId { file_id: FileId(1), index: 25 }, usages: [], value: Known(ItemId { file_id: FileId(1), index: 229 }) }))
[DEBUG nls::linearization] unresolved references: []
[DEBUG lsp_server::msg] < {"jsonrpc":"2.0","id":1,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/yago/Pro/Tweag/projects/nickel/nickel/cartesian.ncl"},"position":{"line":8,"character":23}}}
[DEBUG nls::requests::hover] start of hovered item: ByteIndex(222)
[DEBUG nls::requests::hover] Found item LinearizationItem { env: Environment { current: {}, previous: RefCell { value: Some(Environment { current: {Ident { label: "left" }: ItemId { file_id: FileId(3), index: 16 }}, previous: RefCell { value: Some(Environment { current: {Ident { label: "acc_ext" }: ItemId { file_id: FileId(3), index: 14 }}, previous: RefCell { value: Some(Environment { current: {Ident { label: "right" }: ItemId { file_id: FileId(3), index: 6 }}, previous: RefCell { value: Some(Environment { current: {Ident { label: "left" }: ItemId { file_id: FileId(3), index: 4 }}, previous: RefCell { value: Some(Environment { current: {Ident { label: "f" }: ItemId { file_id: FileId(3), index: 2 }}, previous: RefCell { value: Some(Environment { current: {Ident { label: "map_cartesian" }: ItemId { file_id: FileId(3), index: 0 }}, previous: RefCell { value: Some(Environment { current: {Ident { label: "std" }: ItemId { file_id: FileId(1), index: 0 }}, previous: RefCell { value: None } }) } }) } }) } }) } }) } }) } }) } }, id: ItemId { file_id: FileId(3), index: 24 }, pos: Original(RawSpan { src_id: FileId(3), start: ByteIndex(221), end: ByteIndex(230) }), ty: Type { typ: Dyn, pos: None }, kind: Usage(Resolved(ItemId { file_id: FileId(1), index: 35 })), metadata: None }
[DEBUG lsp_server::msg] > {"jsonrpc":"2.0","id":1,"result":{"contents":[{"language":"nickel","value":"(a -> b -> a) -> a -> Array b -> a"},{"language":"plain","value":"Folds a function over an array. In a functional language like Nickel,\nfolds serve a similar purpose to loops or iterators. `fold_left`\niterates over an array, by repeatedly applying a function to each\nelement, threading an additional arbitrary state (the accumulator, of\ntype `a` in the signature) through the chain of applications.\n\n`fold_left f init [x1, x2, ..., xn]` results in `f (... (f (f init x1) x2) ...) xn`.\n\nThis function is strict in the intermediate accumulator.\n\n# Left vs right\n\nFolds come in two variants, left and right. How to decide which one to\nuse?\n\n- If the folded function isn't associative (such as subtraction), then\n  each variant will give a different result. The choice is dictacted by\n  which one you need. For example:\n\n  ```nickel\n  std.array.fold_right (-) 0 [1, 2, 3, 4]\n   => -2\n  std.array.fold_left (-) 0 [1, 2, 3, 4]\n   => -10\n  ```\n- If the folded function is associative, both `fold_right` and\n  `fold_left` return the same result. In that case, **`fold_left` is\n  generally preferred**, because it forces the evaluation of the\n  intermediate results resulting in less memory consumption and overall\n  better performance (outside of pathological cases).\n  `fold_left` also iterates from the start of the array, which\n  correponds to the usual behavior of loops and iterators in most\n  programming languages. There is one case where `fold_right` might be\n  preferred, see the next point.\n- If the folded function is associative but _(left) short-circuiting_,\n  meaning that it can sometimes determine the result without using the\n  right argument, then `fold_right` provides early return. An example is\n  the boolean AND operator `&&`: when evaluating `left && right`, if\n  `left` is `false`, the whole expression will evaluate to `false`\n  without even evaluating `right`. Consider the following expression:\n\n  ```nickel\n  std.array.replicate 1000 true\n  # gives [false, .. true 1000 times]\n  |> std.array.prepend false\n  |> std.array.fold_right (&&) [false]\n  ```\n\n  Here, `fold_right` will stop at the first element, and the operation\n  runs in constant time, given the definition of `fold_right` and the\n  lazy evaluation of Nickel. If we had used `fold_left` instead, which\n  is closer to a standard iterator, we would have iterated over all of\n  the 1000 elements of the array.\n\n# Examples\n\n```nickel\nfold_left (fun acc e => acc + e) 0 [ 1, 2, 3 ] =>\n  (((0 + 1) + 2) 3) =>\n  6\n```"}],"range":{"end":{"character":31,"line":8},"start":{"character":22,"line":8}}}}

